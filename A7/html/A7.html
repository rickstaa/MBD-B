
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>A7</title><meta name="generator" content="MATLAB 9.4"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-05-23"><meta name="DC.source" content="A7.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h2>Contents</h2><div><ul><li><a href="#1">MBD_B: Assignment 7 - Quick return mechanism</a></li><li><a href="#2">Set up needed symbolic parameters</a></li><li><a href="#3">Intergration parameters</a></li><li><a href="#4">Model Parameters</a></li><li><a href="#5">World parameters</a></li><li><a href="#6">Calculate Initial states</a></li><li><a href="#7">Derive equation of motion</a></li><li><a href="#8">Calculate movement by mean sof a Runge-Kuta 4th order intergration method</a></li><li><a href="#9">Create plots</a></li><li><a href="#10">FUNCTIONS</a></li><li><a href="#11">Runge-Kuta numerical intergration function</a></li><li><a href="#12">Constraint calculation function</a></li><li><a href="#13">Speed correct function</a></li><li><a href="#15">Guass-Newton position correction</a></li><li><a href="#17">ODE Function handle</a></li><li><a href="#18">Calculate (symbolic) Equations of Motion four our setup</a></li><li><a href="#20">Calculate convective component</a></li><li><a href="#21">Convert to function handles</a></li></ul></div><h2 id="1">MBD_B: Assignment 7 - Quick return mechanism</h2><pre>Rick Staa (4511328)
Last edit: 09/05/2018</pre><pre class="codeinput">clear <span class="string">all</span>; close <span class="string">all</span>; clc;
fprintf(<span class="string">'--- A7 ---\n'</span>);
</pre><pre class="codeoutput error">Error using dbstatus
Error: File: C:\Users\ricks\OneDrive\Education\Master\Courses\P3\MBD_B\Assignments\A7\A7.m Line: 77 Column: 22
Invalid expression. When calling a function or indexing a variable, use parentheses. Otherwise, check for mismatched delimiters.
</pre><h2 id="2">Set up needed symbolic parameters</h2><p>Create needed symbolic variables</p><pre class="codeinput">syms <span class="string">phi2</span> <span class="string">phi4</span> <span class="string">phi5</span> <span class="string">phi2d</span> <span class="string">phi4d</span> <span class="string">phi5d</span>

<span class="comment">% Put in parms struct for easy function handling</span>
parms.syms.phi2             = phi2;
parms.syms.phi4             = phi4;
parms.syms.phi5             = phi5;
parms.syms.phi2d            = phi2d;
parms.syms.phi4d            = phi4d;
parms.syms.phi5d            = phi5d;
</pre><h2 id="3">Intergration parameters</h2><pre class="codeinput">time                        = 3;                                        <span class="comment">% Intergration time</span>
parms.h                     = 0.01;                                     <span class="comment">% Intergration step size</span>
parms.tol                   = 1e-12;                                    <span class="comment">% Intergration constraint error tolerance</span>
parms.nmax                  = 10;                                       <span class="comment">% Maximum number of Gauss-Newton drift correction iterations</span>
</pre><h2 id="4">Model Parameters</h2><p>Lengths and distances</p><pre class="codeinput">parms.O2A                   = 0.2;                                      <span class="comment">% Length segment 2 [m]</span>
parms.O4B                   = 0.7;                                      <span class="comment">% Length segment 4 [m]</span>
parms.BC                    = 0.6;                                      <span class="comment">% Length segment 5 [m]</span>
parms.O4O2                  = 0.3;                                      <span class="comment">% Distance between joint 4 and joint 2 [m]</span>
parms.O4G4                  = 0.4;                                      <span class="comment">% Distance bewteen COM4 and joint 4 [m]</span>
parms.BG5                   = 0.3;                                      <span class="comment">% Distance joint 5 and COM 5 [m]</span>
parms.Yc                    = 0.9;                                      <span class="comment">% Height joint C (COM body 6) [m]</span>
parms.O4A                   = sqrt(parms.O2A^2+parms.O4O2^2);           <span class="comment">% Distance between joint 4 and joint 3 [m]</span>

<span class="comment">% Masses and inertias</span>
parms.m3                    = 0.5;                                      <span class="comment">% Body 3 weight [kg]</span>
parms.m4                    = 6;                                        <span class="comment">% Body 4 weight [kg]</span>
parms.m5                    = 4;                                        <span class="comment">% Body 5 weight [kg]</span>
parms.m6                    = 2;                                        <span class="comment">% Body 6 weight [kg]</span>
parms.J2                    = 100;                                      <span class="comment">% Moment of inertia body 2 [kgm^2]</span>
parms.J3                    = 0;                                        <span class="comment">% Moment of inertia body 3 [kgm^2] - Put on 0 because no moment possible</span>
parms.J4                    = 10;                                       <span class="comment">% Moment of inertia body 4 [kgm^2]</span>
parms.J5                    = 6;                                        <span class="comment">% Moment of inertia body 5 [kgm^2]</span>
</pre><h2 id="5">World parameters</h2><p>Gravity</p><pre class="codeinput">parms.g                     = 9.81;                                     <span class="comment">% [parms.m/s^2]</span>

<span class="comment">% Forces</span>
parms.F6_x                  = 1000;                                     <span class="comment">% x force on body 6 [N]</span>
parms.T2                    = 0;                                        <span class="comment">% Torque around joint 6 [Nm]</span>
</pre><h2 id="6">Calculate Initial states</h2><pre class="codeinput">phi2_init                   = 0;
phi4_init                   = atan2(parms.O4O2,parms.O2A);
phi5_init                   = pi-asin((parms.Yc-parms.O4B*sin(phi4_init))/parms.BC);
phi2d_init                  = (150*pi)/60;
phi4d_init                  = 0;
phi5d_init                  = 0;
q0                          = [phi2_init phi4_init phi5_init phi2d_init phi4d_init phi5d_init];
</pre><h2 id="7">Derive equation of motion</h2><pre class="codeinput">[EOM_qdp,C_handle]          = EOM_calc(parms);                         <span class="comment">% Calculate symbolic equations of motion and put in parms struct</span>
parms.C_handle              = C_handle;
</pre><h2 id="8">Calculate movement by mean sof a Runge-Kuta 4th order intergration method</h2><pre class="codeinput">tic
[t_RK4,q_RK4]                         = RK4_custom(EOM_qdp,time,q0,parms);
toc
</pre><h2 id="9">Create plots</h2><pre class="codeinput"><span class="comment">% Plot Angular speed crank as a function of time</span>
q = [sin(1:8*pi);cos(1:8*pi);sin((1:8*pi)-0.25*pi);sin(1:8*pi);cos(1:8*pi);sin((1:8*pi)-0.25*pi)];
figure;
plot(t_RK4,q_RK4(1:3);


<span class="comment">% Plot the sliding speedof slider 3 with respect to rocker 4</span>

<span class="comment">% Plot</span>
</pre><h2 id="10">FUNCTIONS</h2><h2 id="11">Runge-Kuta numerical intergration function</h2><p>This function calculates the motion of the system by means of a Runge-Kuta numerical intergration. This function takes as inputs the parameters of the system (parms), the EOM of the system (parms.EOM) and the initial state.</p><pre class="codeinput"><span class="keyword">function</span> [t,q] = RK4_custom(EOM,q0,parms)

<span class="comment">% Initialise variables</span>
q                   = zeros(length(t),11);                                 <span class="comment">% Create empty state array</span>
q(1,1:size(q0,2))   = q0;                                                  <span class="comment">% Put initial state in array</span>

<span class="comment">% Caculate the motion for the full simulation time by means of a</span>
<span class="comment">% Runge-Kutta4 method</span>

<span class="comment">% Perform intergration till two full rotations of the crank</span>
<span class="keyword">while</span> abs(q(1)) &lt; (4*pi)

    <span class="comment">% Calculate the next state by means of a RK4 method</span>
    q_now_tmp         = num2cell(q(ii,1:end-2),1);                                                <span class="comment">% Create cell for feval function</span>
    K1                = [cell2mat(q_now_tmp(1,end-1:end)),feval(EOM,q_now_tmp{:}).'];             <span class="comment">% Calculate the second derivative at the start of the step</span>
    q1_tmp            = num2cell(cell2mat(q_now_tmp) + (parms.h*0.5)*K1);                         <span class="comment">% Create cell for feval function</span>
    K2                = [cell2mat(q1_tmp(1,end-1:end)),feval(EOM,q1_tmp{:}).'];                   <span class="comment">% Calculate the second derivative halfway the step</span>
    q2_tmp            = num2cell(cell2mat(q_now_tmp) + (parms.h*0.5)*K2);                         <span class="comment">% Refine value calculation with new found derivative</span>
    K3                = [cell2mat(q2_tmp(1,end-1:end)),feval(EOM,q2_tmp{:}).'];                   <span class="comment">% Calculate new derivative at the new refined location</span>
    q3_tmp            = num2cell(cell2mat(q_now_tmp) + (parms.h)*K3);                             <span class="comment">% Calculate state at end step with refined derivative</span>
    K4                = [cell2mat(q3_tmp(1,end-1:end)),feval(EOM,q3_tmp{:}).'];                   <span class="comment">% Calculate last second derivative</span>
    q(ii,end-1:end)   = (1/6)*(K1(3:4)+2*K2(3:4)+2*K3(3:4)+K4(3:4));                              <span class="comment">% Take weighted sum of K1, K2, K3</span>
    q(ii+1,1:end-2)   = cell2mat(q_now_tmp) + (parms.h/6)*(K1+2*K2+2*K3+K4);                      <span class="comment">% Perform euler intergration step</span>

    <span class="comment">% Correct for intergration drift</span>
    [q,error] = gauss_newton(q,parms);                                                            <span class="comment">% Perform Gauss-Newton drift correction</span>

    <span class="comment">% Calculate last acceleration</span>
    <span class="keyword">if</span> ii == (size(t,1)-1)
        q_now_tmp         = num2cell(q(ii+1,1:end-2),1);                                              <span class="comment">% Create cell for feval function</span>
        K1                = [cell2mat(q_now_tmp(1,end-1:end)),feval(EOM,q_now_tmp{:}).'];             <span class="comment">% Calculate the second derivative at the start of the step</span>
        q1_tmp            = num2cell(cell2mat(q_now_tmp) + (parms.h*0.5)*K1);                         <span class="comment">% Create cell for feval function</span>
        K2                = [cell2mat(q1_tmp(1,end-1:end)),feval(EOM,q1_tmp{:}).'];                   <span class="comment">% Calculate the second derivative halfway the step</span>
        q2_tmp            = num2cell(cell2mat(q_now_tmp) + (parms.h*0.5)*K2);                         <span class="comment">% Refine value calculation with new found derivative</span>
        K3                = [cell2mat(q2_tmp(1,end-1:end)),feval(EOM,q2_tmp{:}).'];                   <span class="comment">% Calculate new derivative at the new refined location</span>
        q3_tmp            = num2cell(cell2mat(q_now_tmp) + (parms.h)*K3);                             <span class="comment">% Calculate state at end step with refined derivative</span>
        K4                = [cell2mat(q3_tmp(1,end-1:end)),feval(EOM,q3_tmp{:}).'];                   <span class="comment">% Calculate last second derivative</span>
        q(ii,end-1:end)   = (1/6)*(K1(3:4)+2*K2(3:4)+2*K3(3:4)+K4(3:4));                              <span class="comment">% Take weighted sum of K1, K2, K3</span>
    <span class="keyword">end</span>
<span class="keyword">end</span>

<span class="comment">% Create time array</span>
t                   = (0:parms.h:size(q,1)).';                                                      <span class="comment">% Create time array</span>
<span class="keyword">end</span>
</pre><h2 id="12">Constraint calculation function</h2><pre class="codeinput"><span class="keyword">function</span> [C,Cd] = constraint_calc(q)

<span class="comment">% Get needed angles out</span>
phi2            = q(1);
phi4            = q(2);
phi5            = q(3);

<span class="comment">% Calculate the two needed constraints</span>
C               = [parms.O4A*cos(phi4)+parms.O2A*cos(phi2)           <span class="keyword">...</span>
                   parms.O4B*sin(phi4)+parms.BC*sin(phi5)-parms.Yc];

<span class="comment">% Calculate constraint derivative</span>
Cd              = jacobian(C,q);

<span class="keyword">end</span>
</pre><h2 id="13">Speed correct function</h2><pre class="codeinput"><span class="keyword">function</span> [q,error] = gauss_newton(q,parms)
</pre><pre class="codeinput"><span class="comment">% Get rid of the drift by solving a non-linear least square problem by</span>
<span class="comment">% means of the Gaus-Newton method</span>
<span class="comment">% Calculate the two needed constraints</span>
[C,Cd] = constraint_calc(q);

<span class="comment">% Calculate the constraint derivative</span>
</pre><h2 id="15">Guass-Newton position correction</h2><pre class="codeinput">n_iter          = 0;                                                                        <span class="comment">% Set iteration counter</span>
q_tmp           = q(1:3);                                                                   <span class="comment">% Get position data out</span>

<span class="comment">% Solve non-linear constraint least-square problem</span>
<span class="keyword">while</span> ((max(abs(C)) &gt; parms.tol)&amp;&amp; (n_iter &lt; parms.nmax)
    n_iter = n_iter + 1;
    q_del  = Cd.'*inv(Cd*Cd.')*-C;
    q      = q_tmp + q_del;

    <span class="comment">% Recalculate constraint</span>
    [C,Cd]      = constraint_calc(q);
<span class="keyword">end</span>
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><h2 id="17">ODE Function handle</h2><pre class="codeinput"><span class="keyword">function</span> [qdp] = ODE_func(t,q,EOM_qdp)
q_now = num2cell(q',1);
qdp   = feval(EOM_qdp,q_now{:});
qdp   = [q(3);q(4);qdp];
<span class="keyword">end</span>
</pre><h2 id="18">Calculate (symbolic) Equations of Motion four our setup</h2><pre class="codeinput"><span class="keyword">function</span> [qdp_handle,C_handle] = EOM_calc(parms)
</pre><pre class="codeinput"><span class="comment">% Unpack symbolic variables from varargin</span>
phi2            = parms.syms.phi2;
phi4            = parms.syms.phi4;
phi5            = parms.syms.phi5;
phi2d           = parms.syms.phi2d;
phi4d           = parms.syms.phi4d;
phi5d           = parms.syms.phi5d;

<span class="comment">% Create generalized coordinate vectors</span>
q               = [phi2;phi4;phi5];
qp              = [phi2d;phi4d;phi5d];

<span class="comment">% COM of the bodies expressed in generalised coordinates</span>
<span class="comment">% x2              = 0;</span>
<span class="comment">% y2              = parms.O4O2;</span>
x3              = parms.O2A*cos(phi2);
y3              = parms.O4O2+parms.O2A*sin(phi2);
x4              = parms.O4G4*cos(phi4);
y4              = parms.O4G4*sin(phi4);
x5              = parms.O4B*cos(phi4)+parms.BG5*cos(phi5);
y5              = parms.O4B*sin(phi4)+parms.BG5*sin(phi5);
x6              = parms.O4B*cos(phi4)+parms.BC*cos(phi5);
<span class="comment">% y6             = parms.O4B*sin(phi4)+parms.BC*sin(phi5);</span>

<span class="comment">% Create mass matrix</span>
<span class="comment">% x2 = 0, y2 = 0 and y5 =0 also no moments around slider 3 and 6</span>
parms.M         = diag([parms.J2,parms.m3,parms.m3,parms.J3,parms.m4,parms.m4,parms.J4,parms.m5,parms.m5,parms.J5,parms.m6]);

<span class="comment">% Put in one state vector</span>
x               = [phi2;x3;y3;phi4;x4;y4;phi4;x5;y5;phi5;x6];

<span class="comment">% Calculate the two needed constraints</span>
C               = [parms.O4A*cos(phi4)+parms.O2A*cos(phi2)           <span class="keyword">...</span>
    parms.O4B*sin(phi4)+parms.BC*sin(phi5)-parms.Yc];

<span class="comment">% Compute the jacobian of state and constraints</span>
Jx_q            = simplify(jacobian(x,q.'));
JC_q            = simplify(jacobian(C,q.'));
</pre><h2 id="20">Calculate convective component</h2><pre class="codeinput">Jx_dq           = jacobian(Jx_q*qp,q);
JC_dq           = jacobian(JC_q*qp,q);

<span class="comment">% Solve with virtual power</span>
M_bar           = Jx_q.'*parms.M*Jx_q;

<span class="comment">% Add forces F=[M2,F3_x,F3_y,M3,F4_x,F4_y,M4,F5_x,F5_y,M5,F6_x];</span>
F               = [parms.T2, 0, -parms.m3*parms.g, 0, 0, -parms.m4*parms.g, 0, 0, -parms.m5*parms.g, 0, parms.F6_x];

<span class="comment">% Create system of DAE</span>
A = [M_bar JC_q.'; JC_q zeros(size(JC_q,1))];
B = [Jx_q.'*(F.'-parms.M*Jx_dq*qp); <span class="keyword">...</span>
    -JC_dq*qp];

<span class="comment">% Calculate result expressed in generalized coordinates</span>
qdp             = A\B;

<span class="comment">% % Get result back in COM coordinates</span>
<span class="comment">% xdp     = simplify(jacobian(xp,qp.'))*qdp + simplify(jacobian(xp,q.'))*qp;</span>
</pre><h2 id="21">Convert to function handles</h2><p>xdp_handle       = matlabFunction(xdp);                                 % Create function handle of EOM in terms of COM positions</p><pre class="codeinput">qdp_handle      = matlabFunction(simplify(qdp));                                    <span class="comment">% Create function handle of EOM in terms of generalised coordinates</span>
<span class="comment">% matlabFunction(qdp,'file',qdp_cal')</span>

<span class="comment">% Constraint function handle</span>
C_handle        = matlabFunction(simplify(C));
</pre><pre class="codeinput"><span class="keyword">end</span>
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2018a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% MBD_B: Assignment 7 - Quick return mechanism
%  Rick Staa (4511328)
%  Last edit: 09/05/2018
clear all; close all; clc;
fprintf('REPLACE_WITH_DASH_DASH- A7 REPLACE_WITH_DASH_DASH-\n');

%% Set up needed symbolic parameters
% Create needed symbolic variables
syms phi2 phi4 phi5 phi2d phi4d phi5d

% Put in parms struct for easy function handling
parms.syms.phi2             = phi2;
parms.syms.phi4             = phi4;
parms.syms.phi5             = phi5;
parms.syms.phi2d            = phi2d;
parms.syms.phi4d            = phi4d;
parms.syms.phi5d            = phi5d;

%% Intergration parameters
time                        = 3;                                        % Intergration time
parms.h                     = 0.01;                                     % Intergration step size
parms.tol                   = 1e-12;                                    % Intergration constraint error tolerance
parms.nmax                  = 10;                                       % Maximum number of Gauss-Newton drift correction iterations

%% Model Parameters
% Lengths and distances
parms.O2A                   = 0.2;                                      % Length segment 2 [m]
parms.O4B                   = 0.7;                                      % Length segment 4 [m]
parms.BC                    = 0.6;                                      % Length segment 5 [m]
parms.O4O2                  = 0.3;                                      % Distance between joint 4 and joint 2 [m]
parms.O4G4                  = 0.4;                                      % Distance bewteen COM4 and joint 4 [m]
parms.BG5                   = 0.3;                                      % Distance joint 5 and COM 5 [m]
parms.Yc                    = 0.9;                                      % Height joint C (COM body 6) [m]
parms.O4A                   = sqrt(parms.O2A^2+parms.O4O2^2);           % Distance between joint 4 and joint 3 [m]

% Masses and inertias
parms.m3                    = 0.5;                                      % Body 3 weight [kg]
parms.m4                    = 6;                                        % Body 4 weight [kg]
parms.m5                    = 4;                                        % Body 5 weight [kg]
parms.m6                    = 2;                                        % Body 6 weight [kg]
parms.J2                    = 100;                                      % Moment of inertia body 2 [kgm^2]
parms.J3                    = 0;                                        % Moment of inertia body 3 [kgm^2] - Put on 0 because no moment possible
parms.J4                    = 10;                                       % Moment of inertia body 4 [kgm^2]
parms.J5                    = 6;                                        % Moment of inertia body 5 [kgm^2]

%% World parameters
% Gravity
parms.g                     = 9.81;                                     % [parms.m/s^2]

% Forces
parms.F6_x                  = 1000;                                     % x force on body 6 [N]
parms.T2                    = 0;                                        % Torque around joint 6 [Nm]

%% Calculate Initial states
phi2_init                   = 0;
phi4_init                   = atan2(parms.O4O2,parms.O2A);
phi5_init                   = pi-asin((parms.Yc-parms.O4B*sin(phi4_init))/parms.BC);
phi2d_init                  = (150*pi)/60;
phi4d_init                  = 0;
phi5d_init                  = 0;
q0                          = [phi2_init phi4_init phi5_init phi2d_init phi4d_init phi5d_init];

%% Derive equation of motion
[EOM_qdp,C_handle]          = EOM_calc(parms);                         % Calculate symbolic equations of motion and put in parms struct
parms.C_handle              = C_handle;

%% Calculate movement by mean sof a Runge-Kuta 4th order intergration method
tic
[t_RK4,q_RK4]                         = RK4_custom(EOM_qdp,time,q0,parms);
toc

%% Create plots

% Plot Angular speed crank as a function of time
q = [sin(1:8*pi);cos(1:8*pi);sin((1:8*pi)-0.25*pi);sin(1:8*pi);cos(1:8*pi);sin((1:8*pi)-0.25*pi)];
figure;
plot(t_RK4,q_RK4(1:3);


% Plot the sliding speedof slider 3 with respect to rocker 4

% Plot

%% FUNCTIONS

%% Runge-Kuta numerical intergration function
% This function calculates the motion of the system by means of a
% Runge-Kuta numerical intergration. This function takes as inputs the 
% parameters of the system (parms), the EOM of the system (parms.EOM) 
% and the initial state.
function [t,q] = RK4_custom(EOM,q0,parms)

% Initialise variables
q                   = zeros(length(t),11);                                 % Create empty state array
q(1,1:size(q0,2))   = q0;                                                  % Put initial state in array

% Caculate the motion for the full simulation time by means of a
% Runge-Kutta4 method

% Perform intergration till two full rotations of the crank
while abs(q(1)) < (4*pi)
    
    % Calculate the next state by means of a RK4 method
    q_now_tmp         = num2cell(q(ii,1:end-2),1);                                                % Create cell for feval function
    K1                = [cell2mat(q_now_tmp(1,end-1:end)),feval(EOM,q_now_tmp{:}).'];             % Calculate the second derivative at the start of the step
    q1_tmp            = num2cell(cell2mat(q_now_tmp) + (parms.h*0.5)*K1);                         % Create cell for feval function
    K2                = [cell2mat(q1_tmp(1,end-1:end)),feval(EOM,q1_tmp{:}).'];                   % Calculate the second derivative halfway the step
    q2_tmp            = num2cell(cell2mat(q_now_tmp) + (parms.h*0.5)*K2);                         % Refine value calculation with new found derivative
    K3                = [cell2mat(q2_tmp(1,end-1:end)),feval(EOM,q2_tmp{:}).'];                   % Calculate new derivative at the new refined location
    q3_tmp            = num2cell(cell2mat(q_now_tmp) + (parms.h)*K3);                             % Calculate state at end step with refined derivative
    K4                = [cell2mat(q3_tmp(1,end-1:end)),feval(EOM,q3_tmp{:}).'];                   % Calculate last second derivative
    q(ii,end-1:end)   = (1/6)*(K1(3:4)+2*K2(3:4)+2*K3(3:4)+K4(3:4));                              % Take weighted sum of K1, K2, K3
    q(ii+1,1:end-2)   = cell2mat(q_now_tmp) + (parms.h/6)*(K1+2*K2+2*K3+K4);                      % Perform euler intergration step
    
    % Correct for intergration drift
    [q,error] = gauss_newton(q,parms);                                                            % Perform Gauss-Newton drift correction
    
    % Calculate last acceleration
    if ii == (size(t,1)-1)
        q_now_tmp         = num2cell(q(ii+1,1:end-2),1);                                              % Create cell for feval function
        K1                = [cell2mat(q_now_tmp(1,end-1:end)),feval(EOM,q_now_tmp{:}).'];             % Calculate the second derivative at the start of the step
        q1_tmp            = num2cell(cell2mat(q_now_tmp) + (parms.h*0.5)*K1);                         % Create cell for feval function
        K2                = [cell2mat(q1_tmp(1,end-1:end)),feval(EOM,q1_tmp{:}).'];                   % Calculate the second derivative halfway the step
        q2_tmp            = num2cell(cell2mat(q_now_tmp) + (parms.h*0.5)*K2);                         % Refine value calculation with new found derivative
        K3                = [cell2mat(q2_tmp(1,end-1:end)),feval(EOM,q2_tmp{:}).'];                   % Calculate new derivative at the new refined location
        q3_tmp            = num2cell(cell2mat(q_now_tmp) + (parms.h)*K3);                             % Calculate state at end step with refined derivative
        K4                = [cell2mat(q3_tmp(1,end-1:end)),feval(EOM,q3_tmp{:}).'];                   % Calculate last second derivative
        q(ii,end-1:end)   = (1/6)*(K1(3:4)+2*K2(3:4)+2*K3(3:4)+K4(3:4));                              % Take weighted sum of K1, K2, K3
    end
end

% Create time array
t                   = (0:parms.h:size(q,1)).';                                                      % Create time array
end

%% Constraint calculation function
function [C,Cd] = constraint_calc(q)

% Get needed angles out
phi2            = q(1);
phi4            = q(2);
phi5            = q(3);

% Calculate the two needed constraints
C               = [parms.O4A*cos(phi4)+parms.O2A*cos(phi2)           ...
                   parms.O4B*sin(phi4)+parms.BC*sin(phi5)-parms.Yc];    
 
% Calculate constraint derivative
Cd              = jacobian(C,q);

end

%% Speed correct function
function [q,error] = gauss_newton(q,parms)

% Get rid of the drift by solving a non-linear least square problem by
% means of the Gaus-Newton method
% Calculate the two needed constraints
[C,Cd] = constraint_calc(q);
               
% Calculate the constraint derivative

%% Guass-Newton position correction
n_iter          = 0;                                                                        % Set iteration counter
q_tmp           = q(1:3);                                                                   % Get position data out

% Solve non-linear constraint least-square problem
while ((max(abs(C)) > parms.tol)&& (n_iter < parms.nmax)
    n_iter = n_iter + 1;
    q_del  = Cd.'*inv(Cd*Cd.')*-C;
    q      = q_tmp + q_del;
    
    % Recalculate constraint
    [C,Cd]      = constraint_calc(q);
end
end

%% ODE Function handle
function [qdp] = ODE_func(t,q,EOM_qdp)
q_now = num2cell(q',1);
qdp   = feval(EOM_qdp,q_now{:});
qdp   = [q(3);q(4);qdp];
end

%% Calculate (symbolic) Equations of Motion four our setup
function [qdp_handle,C_handle] = EOM_calc(parms)

% Unpack symbolic variables from varargin
phi2            = parms.syms.phi2;
phi4            = parms.syms.phi4;
phi5            = parms.syms.phi5;
phi2d           = parms.syms.phi2d;
phi4d           = parms.syms.phi4d;
phi5d           = parms.syms.phi5d;

% Create generalized coordinate vectors
q               = [phi2;phi4;phi5];
qp              = [phi2d;phi4d;phi5d];

% COM of the bodies expressed in generalised coordinates
% x2              = 0;
% y2              = parms.O4O2;
x3              = parms.O2A*cos(phi2);
y3              = parms.O4O2+parms.O2A*sin(phi2);
x4              = parms.O4G4*cos(phi4);
y4              = parms.O4G4*sin(phi4);
x5              = parms.O4B*cos(phi4)+parms.BG5*cos(phi5);
y5              = parms.O4B*sin(phi4)+parms.BG5*sin(phi5);
x6              = parms.O4B*cos(phi4)+parms.BC*cos(phi5);
% y6             = parms.O4B*sin(phi4)+parms.BC*sin(phi5);

% Create mass matrix
% x2 = 0, y2 = 0 and y5 =0 also no moments around slider 3 and 6
parms.M         = diag([parms.J2,parms.m3,parms.m3,parms.J3,parms.m4,parms.m4,parms.J4,parms.m5,parms.m5,parms.J5,parms.m6]);

% Put in one state vector
x               = [phi2;x3;y3;phi4;x4;y4;phi4;x5;y5;phi5;x6];

% Calculate the two needed constraints
C               = [parms.O4A*cos(phi4)+parms.O2A*cos(phi2)           ...
    parms.O4B*sin(phi4)+parms.BC*sin(phi5)-parms.Yc];

% Compute the jacobian of state and constraints
Jx_q            = simplify(jacobian(x,q.'));
JC_q            = simplify(jacobian(C,q.'));

%% Calculate convective component
Jx_dq           = jacobian(Jx_q*qp,q);
JC_dq           = jacobian(JC_q*qp,q);

% Solve with virtual power
M_bar           = Jx_q.'*parms.M*Jx_q;

% Add forces F=[M2,F3_x,F3_y,M3,F4_x,F4_y,M4,F5_x,F5_y,M5,F6_x];
F               = [parms.T2, 0, -parms.m3*parms.g, 0, 0, -parms.m4*parms.g, 0, 0, -parms.m5*parms.g, 0, parms.F6_x];

% Create system of DAE
A = [M_bar JC_q.'; JC_q zeros(size(JC_q,1))];
B = [Jx_q.'*(F.'-parms.M*Jx_dq*qp); ...
    -JC_dq*qp];

% Calculate result expressed in generalized coordinates
qdp             = A\B;

% % Get result back in COM coordinates
% xdp     = simplify(jacobian(xp,qp.'))*qdp + simplify(jacobian(xp,q.'))*qp;

%% Convert to function handles
% xdp_handle       = matlabFunction(xdp);                                 % Create function handle of EOM in terms of COM positions
qdp_handle      = matlabFunction(simplify(qdp));                                    % Create function handle of EOM in terms of generalised coordinates
% matlabFunction(qdp,'file',qdp_cal')

% Constraint function handle
C_handle        = matlabFunction(simplify(C));

end
##### SOURCE END #####
--></body></html>